CFile(f, script) ::= <<
#include \<stdio.h>
#include "wich.h"

<script>
>>

Script(s,functions,varDefs,stats) ::= <<
<varDefs:varDefine()>
<functions:funcDecl()>
<functions>
int main(int argc, char *argv[])
{
	<varDefs:varInit();separator="\n">
	<stats;separator="\n">
	<s.localVars:{v|DEREF(<v>);}; separator="\n">
	<s.localTemps:{t|DEREF(tmp<t>);}; separator="\n">
	return 0;
}<\n>
>>

varDefine(varDefTemplate)  ::= "<varDefTemplate.type> <varDefTemplate.v.name>;<\n>"
varInit(varDefTemplate)    ::= "<varDefTemplate.v.name> = <varDefTemplate.expr>;"

funcDecl(funcTemplate)     ::= <<
<funcTemplate.returnType; null="void"> <funcTemplate.f.funcName>(<funcTemplate.args;separator=",">);<\n>
>>

Func(f,returnType,args,body)::=<<
<returnType; null="void"> <f.funcName>(<args;separator=",">)
<body>

>>

Block(b,varDefs,stats,returnStat,returnTemps,returnTmpAssign)::= <<
{
	<if(b.argsRef)><b.argsRef:{arg|REF(<arg>);};separator="\n"><endif>
	<if(varDefs)><varDefs;separator="\n"><endif>
	<if(returnTemps)><returnTemps;separator="\n"><endif>
	<if(stats)><stats;separator="\n"><endif>
	<returnTmpAssign>
	<if(b.returnRefVar)>REF(<b.returnRefVar>);<endif>
	<if(b.localVars)><b.localVars:{deRef|DEREF(<deRef>);};separator="\n"><endif>
	<if(b.localTemps)><b.localTemps:{t|DEREF(tmp<t>);};separator="\n"><endif>
	<if(returnStat)><returnStat><endif>
}
>>

AssignStat(a,right,localTemps)::=<<
<if(localTemps)><localTemps;separator="\n">
COPY_ON_WRITE(<a.varName>);<endif>
<a.varName> = <right>;
>>

CallStat(c,callExpr,localTemps) ::=<<
<if(localTemps)><localTemps;separator="\n"><endif>
<callExpr>;
>>

ElementAssignStat(e,index,rExpr) ::= <<
COPY_ON_WRITE(<e.eName>);
<e.eName>->data[<index>-1] = <rExpr>;
>>

IfStat(i,condition,stat,elseStat) ::= <<
if (<condition>) <stat><if(elseStat)>
else <elseStat><endif>
>>

WhileStat(w,condition, stat) ::= <<
while (<condition>) <stat;separator="\n">
>>

ReturnStat(r,rExpr)  ::= <<
<if(r.tmpIndex)>return tmp<r.tmpIndex>;<else>return <rExpr>;<endif>
>>

VarDefStat(v,type,expr,localTemps) ::= <<
<if(localTemps)><localTemps;separator="\n"><endif>
<type><v.name> = <expr>;<if(v.ref)>
REF(<v.ref>);<endif>
>>

BlockStat(b,block) ::= <<
<block>
>>

PrintStat(p) ::= <<
print();
>>

PrintStrStat(ps,expr,localTemps) ::= <<
<if(localTemps)><localTemps;separator="\n"><endif>
print_<ps.type>(<expr>);
>>

PrintVecStat(pv,expr,localTemps) ::= <<
<if(localTemps)><localTemps;separator="\n"><endif>
print_<pv.type>(<expr>);
>>

PrintIntStat(pi,expr) ::= <<
printf("%d\n", <expr>);
>>

PrintFloatStat(pf,expr) ::= <<
printf("%1.2f\n", <expr>);
>>

AtomExpr(a,primaryExpr) ::= "<primaryExpr>"

PrimaryExpr(p) ::= "<p.content>"

FuncCall(c,args) ::= <<
<if(c.localTmp)>tmp<c.localTmp>=<c.funcName>(<args;separator=",">)<else><c.funcName>(<args;separator=",">)<endif>
>>

StringNewFunCall(s) ::= <<
<if(s.localTmp)>tmp<s.localTmp>=<s.funcName>(<s.literal>)<else><s.funcName>(<s.literal>)<endif>
>>

VectorNewFunCall(v,args) ::= <<
<if(v.localTmp)>tmp<v.localTmp>=<v.funcName>((double[]){<args;separator=",">},<v.vectorNewSize>)
<else><v.funcName>((double []){<args;separator=",">}, <v.vectorNewSize>)<endif>
>>

OpFunCall(op,args) ::= <<
<if(op.localTmp)>tmp<op.localTmp>=<op.funcName>(<args;separator=",">)<\\>
<else><op.funcName>(<args;separator=",">)<\\>
<endif>
>>

StrToCharFunCall(str,arg) ::= <<
<if(str.localTmp)>tmp<str.localTmp>=<str.funcName>(<arg>)<endif>
>>

StrIndexExpr(s,expr) ::= <<
<if(s.localTmp)>tmp<s.localTmp>=<endif><s.objectName>->str[(<expr>)-1]
>>

ReturnTmpExpr(r,expr) ::= "<expr>;"

VexIndexExpr(v,expr) ::= "<v.objectName>->data[(<expr>)-1]"

NegateExpr(n,negateExpr) ::= "- <negateExpr>"

NotExpr(ne,notExpr) ::= "! <notExpr>"

OpExpr(o,lExp,rExp) ::= "<lExp> <o.op> <rExp>"

ParensExpr(p,expression) ::= "(<expression>)"

ArgDef(arg,type) ::= "<type> <arg.name>"

CType(t) ::= "<t.name>"
NonCType(nt) ::= "<nt.name> *"
TmpVarDef(t) ::="<t.typeName> *tmp<t.index>;"

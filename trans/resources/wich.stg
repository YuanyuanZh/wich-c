File(f, script, functions) ::= <<
#include \<stdio.h>
#include "wich.h"

<script.varDefs:globalVarDefine()>
<functions:funcDecl()>
<functions>
<script>
>>

Script(s,stats,varDefs, /* to avoid warning for now */ returnTmpAssign, returnStat, returnTemps) ::= <<
int main(int argc, char *argv[])
{
	<varDefs:globalVarInit();separator="\n">
	<stats;separator="\n">
	<s.localVars:{v|DEREF(<v>);}; separator="\n">
	<s.localTemps:{t|DEREF(tmp<t>);}; separator="\n">
	return 0;
}<\n>
>>

globalVarDefine(varDefTemplate)  ::= "<varDefTemplate.type> <varDefTemplate.v.name>;<\n>"
globalVarInit(varDefTemplate)    ::= "<varDefTemplate.v.name> = <varDefTemplate.expr>;"

funcDecl(funcTemplate)     ::= <<
<funcTemplate.returnType; null="void"> <funcTemplate.f.funcName>(<funcTemplate.args;separator=",">);<\n>
>>

Func(f,returnType,args,body)::=<<
<returnType; null="void"> <f.funcName>(<args;separator=",">)
<body>

>>

Block(b,varDefs,stats,returnStat,returnTemps,returnTmpAssign)::= <<
{
	<b.argsRef:{arg|REF(<arg>);};separator="\n">
	<varDefs;separator="\n">
	<returnTemps;separator="\n">
	<stats;separator="\n">
	<returnTmpAssign>
	<if(b.returnRefVar)>REF(<b.returnRefVar>);<endif>
	<b.localVars:{deRef|DEREF(<deRef>);};separator="\n">
	<b.localTemps:{t|DEREF(tmp<t>);};separator="\n">
	<returnStat>
}
>>

AssignStat(a,right,localTemps)::=<<
<if(localTemps)><localTemps;separator="\n">
COPY_ON_WRITE(<a.varName>);<endif>
<a.varName> = <right>;
>>

CallStat(c,callExpr,localTemps) ::=<<
<if(localTemps)><localTemps;separator="\n"><endif>
<callExpr>;
>>

ElementAssignStat(e,index,rExpr) ::= <<
COPY_ON_WRITE(<e.eName>);
<e.eName>->data[<index>-1] = <rExpr>;
>>

IfStat(i,condition,stat,elseStat) ::= <<
if (<condition>) <stat><if(elseStat)>
else <elseStat><endif>
>>

WhileStat(w,condition, stat) ::= <<
while (<condition>) <stat;separator="\n">
>>

ReturnStat(r,rExpr)  ::= <<
<if(r.tmpIndex)>return tmp<r.tmpIndex>;<else>return <rExpr>;<endif>
>>

VarDefStat(v,type,expr) ::= <<
<type><v.name> = <expr>;<if(v.ref)>
REF(<v.ref>);<endif>
>>

BlockStat(b,block) ::= <<
<block>
>>

StatList(stats) ::= "<stats>"

PrintStat(p) ::= <<
print();
>>

PrintStrStat(ps,expr,localTemps) ::= <<
<localTemps;separator="\n">
print_<ps.type>(<expr>);
>>

PrintVecStat(pv,expr,localTemps) ::= <<
<localTemps;separator="\n">
print_<pv.type>(<expr>);
>>

PrintIntStat(pi,expr) ::= <<
printf("%d\n", <expr>);
>>

PrintFloatStat(pf,expr) ::= <<
printf("%1.2f\n", <expr>);
>>

AtomExpr(a,primaryExpr) ::= "<primaryExpr>"

IntLiteral(i)	::= "<i.value>"
FloatLiteral(f)	::= "<f.value>"
VarRef(v)		::= "<v.name>"

StringLiteral(s) ::= <<
<if(s.localTmp)>tmp<s.localTmp>=<endif><s.funcName>(<s.literal>)
>>

VectorLiteral(v,args) ::= <<
<if(v.localTmp)>tmp<v.localTmp>=<endif><v.funcName>((double []){<args;separator=",">}, <v.vectorNewSize>)
>>

FuncCall(c,retType,args) ::= <<
<if(c.localTmp)>tmp<c.localTmp>=<endif><c.funcName>(<args;separator=",">)
>>

OpFunCall(op,args) ::= <<
<if(op.localTmp)>tmp<op.localTmp>=<endif><op.funcName>(<args;separator=",">)
>>

StrToCharFunCall(str,arg) ::= <<
<if(str.localTmp)>tmp<str.localTmp>=<str.funcName>(<arg>)<endif>
>>

StrIndexExpr(s,expr) ::= <<
<if(s.localTmp)>tmp<s.localTmp>=<endif><s.objectName>->str[(<expr>)-1]
>>

ReturnTmpExpr(r,expr) ::= "<expr>;"

VexIndexExpr(v,expr) ::= "<v.objectName>->data[(<expr>)-1]"

NegateExpr(n,negateExpr) ::= "-<negateExpr>"

NotExpr(ne,notExpr) ::= "!<notExpr>"

OpExpr(o,lExp,rExp) ::= "<lExp> <o.op> <rExp>"

ParensExpr(p,expression) ::= "(<expression>)"

ArgDef(arg,type) ::= "<type> <arg.name>"

IntType(t) ::= "int"
FloatType(t) ::= "double"
VectorType(t) ::= "Vector *"
StringType(t) ::= "String *"
TmpVarDef(t,type) ::="<type> tmp<t.varIndex>;"

RefCountREF(v) ::= "REF(<v.ref>);"
CFile(f, script) ::= <<
#include \<stdio.h>
#include "wich.h"

<script>
>>

Script(s,functions,varDefs,stats) ::= <<
<if(functions)><functions;separator="\n"><endif>
int main(int argc, char *argv[]) {

	<if(varDefs)><varDefs;separator="\n"><endif>
	<if(stats)><stats;separator="\n"><endif>
	<if(s.localVars)><s.localVars:{v|DEREF(<v>);};separator="\n"><endif>
	<if(s.localTemps)><s.localTemps:{t|DEREF(tmp<t>);};separator="\n"><endif>
	return 0;
}
>>

Func(f,returnType,args,body)::=<<
<if(returnType)><returnType><else>void<endif> <f.funcName>(<if(args)><args ;separator=","><endif>) <body>
>>

Block(b,varDefs,stats,returnStat)::= <<
{
	<if(b.argsRef)><b.argsRef:{arg|REF(<arg>);};separator="\n"><endif>
	<if(varDefs)><varDefs;separator="\n"><endif>
	<if(stats)><stats;separator="\n"><endif>
	<if(b.returnVar)>REF(<b.returnVar>);<endif>
	<if(b.localVars)><b.localVars:{deRef|DEREF(<deRef>);};separator="\n"><endif>
	<if(b.localTemps)><b.localTemps:{t|DEREF(tmp<t>);};separator="\n"><endif>
	<if(returnStat)><returnStat><endif>
}
>>

AssignStat(a,right,localTemps)::=<<
<if(localTemps)><localTemps;separator="\n">
COPY_ON_WRITE(<a.varName>);
<endif>
<a.varName> = <right>;
>>

CallStat(c,callExpr,localTemps) ::=<<
<if(localTemps)><localTemps;separator="\n"><endif>
<callExpr>;
>>

ElementAssignStat(e,index,rExpr) ::= <<
COPY_ON_WRITE(<e.eName>);
<e.eName>->data[<index>-1] = <rExpr>;
>>

IfStat(i,condition,stat,elseStat) ::= <<
if(<condition>) <stat>
<if(elseStat)> else <elseStat><endif>
>>

WhileStat(w,condition, stat) ::= <<
while(<condition>)<stat;separator="\n">
>>

ReturnStat(r,rExpr,localTemps)  ::= <<
<if(localTemps)><localTemps;separator="\n"><endif>
return <rExpr>;
>>

VarDefStat(v,type,expr,localTemps) ::= <<
<if(localTemps)><localTemps;separator="\n"><endif>
<type><v.name> = <expr>;
>>

BlockStat(b,block) ::= <<
<block>
>>

PrintStat(p,localTemps,expr) ::=<<
<if(localTemps)><localTemps;separator="\n"><endif>
<if(p.printStr)>print_<p.printStr>(<expr>);
<elseif(p.printVec)>print_<p.printVec>(<expr>);
<elseif(p.printInt)>print("%d\n",<expr>);
<elseif(p.printFloat)>print("%1.2f\n",<expr>);
<else>print();
<endif>
>>

AtomExpr(a,primaryExpr) ::= "<primaryExpr>"

PrimaryExpr(p) ::= "<p.content>"

FuncCall(c,localTmp,args) ::= <<
<if(localTmp)>tmp<localTmp.(index)>=<c.funcName>(<args;separator=",">);
<else><c.funcName>(<args;separator=",">);
<endif>
>>

BuiltInFuncCall(b,localTmp,args) ::= <<
<if(b.stringNewLiteral)><if(localTmp)>tmp<localTmp.(index)>=<b.funcName>(<b.stringNewLiteral>);
<else><b.funcName>(<b.stringNewLiteral>)<endif>
<elseif(b.vectorNewSize)>
<if(localTmp)>tmp<localTmp.(index)>=<b.funcName>((double[]){<args;separator=",">},<b.vectorNewSize>);
<else><b.funcName>((double []){<args;separator=",">}, <b.vectorNewSize>);<endif>
<endif>
>>

StrIndexExpr(s,expr) ::= "<s.objectName>->str[(<expr>)-1]"

VexIndexExpr(v,expr) ::= "<v.objectName>->data[(<expr>)-1]"

NegateExpr(n,negateExpr) ::= "- <negateExpr>"

NotExpr(ne,notExpr) ::= "! <notExpr>"

OpExpr(o,lExpr,rExpr) ::= "(<lExpr>) <o.op> (<rExpr>)"

ParensExpr(p,expression) ::= "(<expression>)"

ArgDef(arg,type) ::= "<type><arg.name>"

CType(t) ::= "<t.name> "
NonCType(nt) ::= "<nt.name> *"
TmpVarDef(t) ::="<t.typeName> * tmp<t.index>;"
